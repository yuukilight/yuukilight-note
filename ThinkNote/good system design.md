
# Everything I know about good system design

软件设计是组合代码，系统设计是组合服务。

软件设计的原语是变量、函数、类；而系统设计的原语则是应用服务器、数据库、缓存、队列、事件总线等。

一个好的系统应该是简单的，平平无奇的。

**一个能正常工作的复杂系统，总是从一个能正常工作的简单系统演化而来的**

## 万恶之源：状态管理

代码(应用、系统、服务)运行过程中需要存储任何信息，哪怕一小会，它就是有状态的，都需要让开发者做出一系列棘手的决策。

**无状态服务出现异常时**
例如 GitHub 内部有一个 API，接收一个PDF文件，返回它的HTML渲染版本。这种无状态的服务如果出现问题，挂了，可以无限次的重启，容器管理器会自动拉起一个新的实例，一切恢复正常。
无状态组件的通信，请求(Request)中包含了所有需要的信息。

**有状态服务出现异常时**
有状态的组件会进入糟糕的状态(bad state)。
如果你的数据库中出现了错误格式的数据导致应用崩溃，就不能简单的通过重启解决，必须手动介入修复。如果数据库磁盘满了，也要想办法清理或扩容。
有状态组件的通信，请求(Request)中只包含了有限的信息，需要额外通过状态去获取其它信息。（这里的状态可以是缓存中的信息，也可以是数据库中的信息）

**如何减少相关问题**
***尽可能减少系统中有状态的组件***
例如设计一个服务专门负责管理状态，其它服务处理无状态的计算任务。
例如系统中有5个服务，在需要向数据库写入信息时，可以将所有的请求或者事件发送给其中的一个服务，集中处理。这样能极大地简化系统的复杂度和潜在的并发问题。

## 数据库的一些争论
1. 多个服务直接访问同一个数据库，强耦合。自定义API访问，弱耦合。
2. 数据库JOIN，JOIN导致数据量爆炸性增长或者需要多个数据源进行关联时在应用层JOIN。
3. ORM(Object-Relational Mapping)

## 快慢分离与缓存的艺术
分离出需要快速响应的工作的最小单元，将其余部分放入后台异步处理。

**后台任务**
1. 队列(Queue)
2. 任务执行器(Job Runner)
   将满操作的任务参数，和scheduled_at 加入任务列表。定期扫描，满足要求的则放入队列执行。

**缓存（Caching）**
当一个慢操作的结果对于多个用户是相同的，缓存就派上用场了。你可以将结果缓存几分钟，避免每次都去执行昂贵的计算或 API 调用。
缓存是另一种形式的状态。它可能会有脏数据，可能与真实数据不同步，可能因为返回了过时数据而引发神秘的 bug。

使用缓存前的黄金法则：先尽力优化！ 比如，为一个慢 SQL 查询加索引，远比直接缓存这个查询结果要明智。

## 系统间的沟通之道：事件、推送与拉取
除了后台任务系统，大公司通常还有一个事件中心（Event Hub），最常见的实现是 Kafka。

**事件(Events)**
事件中心本质上也是个队列，但它传递的不是「执行这个任务」的指令，而是「某件事发生了」的通知。

经典例子是「新用户注册」事件。当一个新用户创建账户时，系统会发布一个事件。然后，多个下游服务可以订阅这个事件并各自采取行动：

- 一个服务负责发送欢迎邮件。
- 一个服务负责进行风险扫描。
- 一个服务负责初始化用户的基础设施。

这种模式实现了服务间的解耦。但 Sean 提醒，不要滥用事件。很多时候，一个简单的服务间 API 调用更直接、更易于追踪和调试。

**推（Push）vs. 拉（Pull）**
当一份数据需要被分发到很多地方时，你有两种选择：

- 拉（Pull）：消费者主动向数据源请求数据。这是 Web 的基本工作模式。缺点是可能产生大量重复请求。
- 推（Push）：数据源在数据更新时，主动将新数据推送给所有已注册的消费者。Gmail 就是这样工作的，新邮件会自动出现，无需刷新。

选择哪种模式，取决于数据变化的频率、消费者数量、以及对数据实时性的要求。

## 为失败而设计：日志、熔断与优雅降级
> 一个好的系统，不仅要在正常时工作良好，更要在异常时表现得体。

在指标方面，除了关注平均响应时间，更要关注 p95 和 p99，即最慢的那 5% 和 1% 的请求耗时。这些慢请求往往来自你最大、最重要的客户。

**日志与指标**
- 因为某个条件返回错误时，把触发的条件也记下来。
- 当你的计费代码决定不为某个事件收费时，把原因记下来。

在指标方面，除了关注平均响应时间，更要关注 p95 和 p99，即最慢的那 5% 和 1% 的请求耗时。这些慢请求往往来自你最大、最重要的客户。

**熔断、重试与幂等性**

- 重试不是万能药：应该使用熔断器模式，当连续收到过多错误时，暂停发送请求一段时间。
- 幂等性：对于写操作的重试尤其危险。经典的解决方案是使用幂等键（Idempotency Key），一个唯一的请求 ID，避免重复执行操作。


**优雅降级：Fail-Open vs. Fail-Closed**

当系统的某个部分失败时，应该如何应对？

- Fail-Open（失败时放行）：例如限流服务，当它故障时应该放行所有请求，避免导致整个产品宕机。
Fail-Closed（失败时阻断）：例如认证授权系统，当它故障时必须阻断所有请求，安全第一。
这个权衡需要根据具体功能的性质来决定。


## 面试中的「表演式设计」
上面说的大道理大家都认可，但一个非常现实的问题被 Hacker News 上的网友辛辣地指了出来：这套「简单为王」的哲学，在面试中可能会让你直接挂掉。

他分享了自己的惨痛经历：

>面试官：「那服务间的背压问题你怎么考虑？」
>我：「这点 QPS 根本不需要考虑这个问题。」
>面试官：「这里为什么不用队列（queue）而是用定时任务（cron job）？」
>我：「我觉得对于这个 App 的需求来说没必要，不过我可以分析一下两者的权衡……」
>面试官：「你会在 SQL 和 NoSQL 之间怎么选？」
>我：「关系不大，团队对哪个更熟悉就用哪个。」

结果可想而知。面试官想要的，往往是让你在白板上画满复杂的箭头和框框，直到它看起来像是「用 Kubernetes 去管理你的 Kubernetes」。

另一位网友补充道，这正是所谓的「LinkedIn 驱动开发」存在的根源。在简历上列出一大堆时髦的技术，远比描述你如何用一个单体应用和单个 PostgreSQL 实例就搞定一切，更能吸引招聘者的眼球。

这无疑是行业的一大讽刺：***我们追求简单的、可维护的系统，但评价体系却在鼓励复杂的、简历驱动的方案。***

## 总结：返璞归真，无聊才是王道
回到文章的起点，Sean 强调：

>好的系统设计，不是关于各种花哨的技巧，而是关于知道如何在正确的地方使用那些无聊的、经过充分测试的组件。
>他打了一个比方：好的系统设计就像好的管道工程。如果你搞得太「激动人心」，那最终很可能会弄得自己满身都是秽物。

在大公司里，这些「无聊」的组件都已是现成的基础设施。好的系统设计，就是像搭乐高一样，把它们正确地拼在一起。

这或许是所有开发者都需要内化的核心思想：我们的目标不是构建一个能写进简历的、看起来很厉害的系统，而是构建一个能在后台默默无闻、稳定运行数年而无人问津的系统。

这，才是系统设计的真正艺术。

## 参考
1. [硅谷资深工程师揭秘：为什么真正优秀的系统设计，往往看起来平平无奇?](https://zhuanlan.zhihu.com/p/1940199166027494020)